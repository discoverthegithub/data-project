#include "class.h"
#include<windows.h>

//----------------------------------Function 1-------------------------------------------------------
int HashTable::hash(const string& key) const
{
    int hashValue = 0;
    for (char c : key)
    {
        hashValue += static_cast<int>(c);
    }
    return hashValue % table_size;
}

//----------------------------------Function 2-------------------------------------------------------
int HashTable::gethash(string& key)
{
    return hash(key);
}

//----------------------------------Constructor-------------------------------------------------------
HashTable::HashTable()
{
    for (int i = 0; i < table_size; ++i)
    {
        table[i] = nullptr;
    }
}
//----------------------------------Destructor-------------------------------------------------------
HashTable::~HashTable()
{
    for (int i = 0; i < table_size; ++i)
    {
        Node* current = table[i];
        while (current != nullptr)
        {
            Node* temp = current;
            current = current->next;
            delete temp;
        }
    }
}


//----------------------------------Function 3-------------------------------------------------------
void HashTable::insert(const User& user)
{
    int index = hash(user.username);
    Node* newNode = new Node(user);
    newNode->next = table[index];
    table[index] = newNode;
}

//----------------------------------Function 4-------------------------------------------------------

User* HashTable::search(const string& username) const
{
    int index = hash(username);
    Node* current = table[index];
    while (current != nullptr)
    {
        if (current->user.username == username)
        {
            return &(current->user);
        }
        current = current->next;
    }
    return nullptr;
}

//----------------------------------Function 5-------------------------------------------------------
UserManagement::UserManagement() : user_count(0), filename("users.csv"), hashTable()
{
    loadUsers();
}
//----------------------------------Function 6-------------------------------------------------------
UserManagement::UserManagement(const string& file) : user_count(0), filename(file), hashTable()
{
    loadUsers();
}

//----------------------------------Function 7-------------------------------------------------------
void UserManagement::loadUsers()
{
    ifstream file(filename);
    if (file.is_open())
    {
        string line;
        while (getline(file, line) && user_count < max_user)
        {
            size_t commaIndex = line.find(',');
            string username = line.substr(0, commaIndex);
            string password = line.substr(commaIndex + 1);
            hashTable.insert(User(username, password));
            users[user_count].username = username;
            users[user_count].password = password;
            ++user_count;
        }
        file.close();
    }
}
//----------------------------------Function 8-------------------------------------------------------

void UserManagement::saveUsers() const
{
    ofstream file(filename);
    if (file.is_open())
    {
        for (int i = 0; i < user_count; ++i)
        {
            file << users[i].username << "," << users[i].password << endl;
        }
        file.close();
    }
    else
    {
        cout << "Error: Could not create or open file for writing." << endl;
        Sleep(1000);
    }
}

//----------------------------------Function 9-------------------------------------------------------
bool UserManagement::registerUser(const string& username, const string& password)
{
    if (user_count < max_user)
    {
        for (int i = 0; i < max_user; ++i)
        {
            if (users[i].username == username)
            {
                cout << "Username already exists. Please choose a different one." << endl;
                Sleep(1000);
                return false;
            }
        }
        for (int i = 0; i < max_user; ++i)
        {
            if (users[i].username.empty())
            {
                users[i].username = username;
                users[i].password = password;
                ++user_count;
                saveUsers();
                cout << "User " << username << " registered successfully." << endl;
                Sleep(1000);
                return true;
            }
        }
    }
    else
    {
        cout << "Maximum number of users reached. Cannot register new user." << endl;
        Sleep(1000);
    }
    return false;
}
//----------------------------------Function 10-------------------------------------------------------
bool UserManagement::loginUser(const string& username, const string& password)
{
    User* user = hashTable.search(username);
    if (user != nullptr && user->password == password)
    {
        user->loggedIn = true;
        saveUsers(); // Save user data after logging in
        cout << "User " << username << " logged in successfully." << endl;
        Sleep(1000);
        return true;
    }
    cout << "Invalid username or password." << endl;
    Sleep(1000);
    return false;
}
//----------------------------------Function 11-------------------------------------------------------
void UserManagement::logoutUser(const string& username)
{
    User* user = hashTable.search(username);
    if (user != nullptr)
    {
        user->loggedIn = false;
        saveUsers(); // Save user data after logging out
        cout << "User " << username << " logged out successfully." << endl;
        Sleep(1000);
    }
    else
    {
        cout << "User not found." << endl;
        Sleep(1000);
    }
}

//----------------------------------Function 12-------------------------------------------------------
User* UserManagement::getUser(const string& username)
{
    return hashTable.search(username);
}
//----------------------------------Function 13-------------------------------------------------------
Node* AVLTree::rotateRight(Node* y)
{
    Node* x = y->left;
    Node* T = x->right;

    x->right = y;
    y->left = T;

    return x;
}
//----------------------------------Function 14-------------------------------------------------------
Node* AVLTree::rotateLeft(Node* x)
{
    Node* y = x->right;
    Node* T = y->left;

    y->left = x;
    x->right = T;

    return y;
}
//----------------------------------Function 15-------------------------------------------------------
int AVLTree::getHeight(Node* node)
{
    if (node == nullptr)
        return 0;
    return max(getHeight(node->left), getHeight(node->right)) + 1;
}

//----------------------------------Function 16-------------------------------------------------------
int AVLTree::getBalanceFactor(Node* node)
{
    if (node == nullptr)
        return 0;
    return getHeight(node->left) - getHeight(node->right);
}
//----------------------------------Function 17-------------------------------------------------------
Node* AVLTree::insertNode(Node* node, const string& value)
{
    if (node == nullptr)
    {
        node = new Node();
        node->project = value;
        return node;
    }

    if (value < node->project)
        node->left = insertNode(node->left, value);
    else if (value > node->project)
        node->right = insertNode(node->right, value);
    else
        return node;

    int balance = getBalanceFactor(node);

    if (balance > 1 && value < node->left->project)
        return rotateRight(node);

    if (balance < -1 && value > node->right->project)
        return rotateLeft(node);

    if (balance > 1 && value > node->left->project) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    if (balance < -1 && value < node->right->project) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    return node;
}
//----------------------------------Function 18-------------------------------------------------------
Node* AVLTree::findMin(Node* node)
{
    if (node == nullptr)
        return nullptr;
    while (node->left != nullptr)
        node = node->left;
    return node;
}
//----------------------------------Function 19-------------------------------------------------------
Node* AVLTree::deleteNode(Node* node, const string& value)
{
    if (node == nullptr)
        return node;

    if (value < node->project)
        node->left = deleteNode(node->left, value);
    else if (value > node->project)
        node->right = deleteNode(node->right, value);
    else {
        if (node->left == nullptr || node->right == nullptr)
        {
            Node* temp = node->left ? node->left : node->right;
            if (temp == nullptr)
            {
                temp = node;
                node = nullptr;
            }
            else
                *node = *temp;
            delete temp;
        }
        else
        {
            Node* temp = findMin(node->right);
            node->project = temp->project;
            node->right = deleteNode(node->right, temp->project);
        }
    }

    if (node == nullptr)
        return node;

    int balance = getBalanceFactor(node);

    if (balance > 1 && getBalanceFactor(node->left) >= 0)
        return rotateRight(node);

    if (balance > 1 && getBalanceFactor(node->left) < 0) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    if (balance < -1 && getBalanceFactor(node->right) <= 0)
        return rotateLeft(node);

    if (balance < -1 && getBalanceFactor(node->right
    ) > 0) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    return node;
}
//----------------------------------Function 20-------------------------------------------------------
void AVLTree::inorderTraversal(Node* node)
{
    if (node != nullptr)
    {
        inorderTraversal(node->left);
        cout << node->project << endl;
        inorderTraversal(node->right);
    }
}
//----------------------------------Function 21-------------------------------------------------------
void AVLTree::inorderTraversalToFile(Node* node, ofstream& file)
{
    if (node != nullptr) {
        inorderTraversalToFile(node->left, file);
        file << node->project << endl;
        inorderTraversalToFile(node->right, file);
    }
}
//----------------------------------Constructor-------------------------------------------------------
AVLTree::AVLTree() : root(nullptr) {}

//----------------------------------Function 22-------------------------------------------------------
void AVLTree::addFile(const string& value)
{
    root = insertNode(root, value);
}
//----------------------------------Function 23-------------------------------------------------------
void AVLTree::deleteFile(const string& value) {
    root = deleteNode(root, value);
}
//----------------------------------Function 24-------------------------------------------------------
void AVLTree::displayRepository()
{
    inorderTraversal(root);
}
//----------------------------------Function 24-------------------------------------------------------
Repository::Repository() : current_index(0)
{
    for (int i = 0; i < 100; ++i)
        repositories[i] = nullptr;
}
//----------------------------------Function 25-------------------------------------------------------
void Repository::createRepository(const string& name, int hashVal)
{
    // Construct file names based on the hash value to differenciate between different users
    string repoFileName = "repositoryname" + to_string(hashVal) + ".txt";
    string privateRepoFileName = "privaterepository" + to_string(hashVal) + ".txt";

    // Open repository file to count the number of lines
    ifstream repoNamesFile(repoFileName);
    int lineCount = 0;
    string line;
    while (getline(repoNamesFile, line))
    {
        if (!line.empty()) {
            lineCount++;
        }
    }
    repoNamesFile.close();

    // Set currentIndex based on the line count
    int currentIndex = lineCount;

    if (currentIndex >= 100)
    {
        cout << "Cannot create more repositories. Maximum limit reached." << endl;
        Sleep(1000);
        return;
    }

    // Ask the user whether the repository should be private or public
    int privacyChoice;
    do
    {
        cout << "Do you want to make the repository private or public?" << endl;
        cout << "Enter 1 for public, 0 for private: ";
        cin >> privacyChoice;
        if (privacyChoice == 0 || privacyChoice == 1)
        {
            break; // Valid choice, exit loop
        }
        else
        {
            cout << "Invalid choice. Please enter 1 for public or 0 for private." << endl;
            Sleep(1000);
        }
    } while (true);

    string password;
    if (privacyChoice == 0)
    {
        cout << "Enter the password for the private repository: ";
        cin >> password;
        Sleep(1000);
    }

    // Store the repository name in repositorynames.txt
    ofstream repoNamesFileAppend(repoFileName, ios::app);
    if (!repoNamesFileAppend.is_open())
    {
        cout << "Error: Unable to open " << repoFileName << " for writing." << endl;
        Sleep(1000);
        return;
    }
    repoNamesFileAppend << name << endl;
    repoNamesFileAppend.close();

    // Store the repository name and password (if private) in privaterepository.txt
    if (privacyChoice == 0)
    {
        ofstream privateRepoFile(privateRepoFileName, ios::app);
        if (!privateRepoFile.is_open()) {
            cout << "Error: Unable to open " << privateRepoFileName << " for writing." << endl;
            Sleep(1000);
            return;
        }
        privateRepoFile << name << "," << password << endl;
        Sleep(1000);
        privateRepoFile.close();
    }

    // Store the repository at the current index and increment currentIndex
    repositories[currentIndex] = new AVLTree(); // Making an avl tree at that line so each file of that repository will be in it
    cout << "Repository '" << name << "' created at index: " << currentIndex << endl;
    Sleep(1000);
    currentIndex++;

}
//----------------------------------Function 26-------------------------------------------------------
void Repository::addFileToRepository(int hashVal)
{
    // Construct repository file name based on the hash value
    string repoFileName = "repositoryname" + to_string(hashVal) + ".txt";

    // Open repository file to find the repository names
    ifstream repoNameFile(repoFileName);
    string repoName;
    string repositories[100]; // Array to store repository names
    int repoCount = 0; // Variable to keep track of the number of repositories

    if (repoNameFile.is_open())
    {
        while (getline(repoNameFile, repoName))
        {
            repositories[repoCount] = repoName; // Store repository name in the array
            repoCount++;
            if (repoCount >= 100) // Ensure not to exceed the array size
                break;
        }
        repoNameFile.close();
    }
    else
    {
        cout << "Error: Unable to open " << repoFileName << "." << endl;
        Sleep(1000);
        return;
    }

    // Display all the repositories
    cout << "Repositories:" << endl;
    for (int i = 0; i < repoCount; ++i)
    {
        cout << i << ": " << repositories[i] << endl;
    }

    // Ask the user to select a repository index
    int index;
    cout << "Enter the index of the repository to add the file: ";
    cin >> index;
    cin.ignore();

    // Check if the selected index is valid
    if (index < 0 || index >= repoCount)
    {
        cout << "Invalid repository index." << endl;
        return;
    }

    string projectName;
    cout << "Enter the name of the project to add: ";
    getline(cin, projectName);

    // Construct repository file name with the selected repository name
    string repositoryFileName = repositories[index] + ".txt";

    // Open the repository file for the selected repository name
    ofstream repositoryFile(repositoryFileName, ios::app);
    if (!repositoryFile.is_open())
    {
        cout << "Error: Unable to open repository file for writing." << endl;
        Sleep(1000);
        return;
    }

    // Add the project name to the repository file
    repositoryFile << projectName << endl;
    repositoryFile.close();

    // Create a file with the project name and ask the user to input the content
    ofstream projectFile(projectName + ".txt");

    if (projectFile.is_open())
    {
        cout << "Enter the content of the file for project " << projectName << ":" << endl;
        string content;
        getline(cin, content); // Get the content from the user
        projectFile << content << endl; // Write the content to the file
        projectFile.close();
        cout << "File added to repository '" << repositories[index] << "'." << endl;
        Sleep(1000);
    }
    else
    {
        cout << "Error: Unable to create project file." << endl;
        Sleep(1000);
    }
}


//----------------------------------Function 27-------------------------------------------------------

void Repository::deleteFileFromRepository(int index, int hashVal)
{
    if (index < 0 || index >= 100) {
        cout << "Invalid repository index." << endl;
        Sleep(1000);
        return;
    }

    // Construct repository file name based on the hash value
    string repoFileName = "repositoryname" + to_string(hashVal) + ".txt";

    ifstream repoNameFile(repoFileName);
    string repoName;
    if (repoNameFile)
    {
        // Count the number of repositories in the file
        int numRepositories = 0;
        while (getline(repoNameFile, repoName))
        {
            numRepositories++;
        }
        repoNameFile.close();

        // Check if the provided index is valid
        if (index >= numRepositories) {
            cout << "Invalid repository index." << endl;
            Sleep(1000);
            return;
        }

        // Reset the file pointer to the beginning
        repoNameFile.open(repoFileName);
        for (int i = 0; i <= index; ++i)
        {
            getline(repoNameFile, repoName);
        }
        repoNameFile.close();
    }
    else
    {
        cout << "Error: Unable to open " << repoFileName << "." << endl;
        Sleep(1000);
        return;
    }

    ifstream repositoryFile(repoName + ".txt");
    if (!repositoryFile)
    {
        cout << "Error: Unable to open repository file for reading." << endl;
        Sleep(1000);
        return;
    }

    cout << "Contents of repository '" << repoName << "' at index " << index << ":" << endl;
    Sleep(1000);

    string projectName;
    int projectIndex = 0;
    while (getline(repositoryFile, projectName))
    {
        cout << ++projectIndex << ". " << projectName << endl;
    }
    repositoryFile.close();

    int projectNumber;
    do
    {
        cout << "Enter the project number you want to delete (0 to return to the main menu): ";
        cin >> projectNumber; // Taking the input of line number for the file where project name is written
        if (projectNumber == 0)
        {
            return; // Return to main menu
        }
        else if (projectNumber < 1 || projectNumber > projectIndex)
        {
            cout << "Invalid project number. Please enter a valid project number." << endl;
            Sleep(1000);
        }
        else
        {  // Opening that file and going to that line number provided by user and reading the string in that line
            ifstream projectFile(repoName + ".txt");
            if (projectFile)
            {
                string projectLine;
                for (int i = 0; i < projectNumber; ++i)
                {
                    getline(projectFile, projectLine);
                }
                projectFile.close();

                string projectFileName = projectLine + ".txt";

                // Deleting the file where project's content was written
                if (remove(projectFileName.c_str()) != 0)
                {
                    cout << "Error: Unable to delete project file." << endl;
                    Sleep(1000);
                    return;
                }

                ifstream repoFileIn(repoName + ".txt");
                if (!repoFileIn) {
                    cout << "Error: Unable to open repository file for reading." << endl;
                    Sleep(1000);
                    return;
                }

                ofstream repoFileOut(repoName + "_temp.txt");
                if (!repoFileOut)
                {
                    cout << "Error: Unable to open repository file for writing." << endl;
                    Sleep(1000);
                    return;
                }

                string line;
                int currentLine = 0;
                while (getline(repoFileIn, line))
                {
                    ++currentLine;
                    if (currentLine != projectNumber)
                    {
                        repoFileOut << line << endl;
                    }
                }
                repoFileIn.close();
                repoFileOut.close();

                if (remove((repoName + ".txt").c_str()) != 0)
                {
                    cout << "Error: Unable to remove original repository file." << endl;
                    Sleep(1000);
                    return;
                }
                if (rename((repoName + "_temp.txt").c_str(), (repoName + ".txt").c_str()) != 0)
                {
                    cout << "Error: Unable to rename temp repository file." << endl;
                    Sleep(1000);
                    return;
                }

                cout << "Project deleted successfully." << endl;
                Sleep(1000);
                return;
            }
            else
            {
                cout << "Error: Unable to open project file for reading." << endl;
                Sleep(1000);
                return;
            }
        }
    } while (true);
}
//----------------------------------Function 28-------------------------------------------------------

string Repository::getLineFromFile(const string& fileName, int lineNum)
{
    ifstream file(fileName);
    string line;
    for (int i = 0; i < lineNum; ++i)
    {
        if (!getline(file, line))
        {
            return ""; // Return empty string if lineNum exceeds the number of lines in the file
        }
    }
    return line;
}
//----------------------------------Function 29-------------------------------------------------------

void Repository::displayRepository(int index, int hashVal) {
    if (index < 0 || index >= 100) {
        cout << "Invalid repository index." << endl;
        Sleep(1000);
        return;
    }

    // Construct repository file name based on the hash value
    string repoFileName = "repositoryname" + to_string(hashVal) + ".txt";

    // Check if privaterepository file exists
    string privateRepoFileName = "privaterepository" + to_string(hashVal) + ".txt";
    bool isPrivate = false;
    string repoName; // Initialize repoName here

    // Open the repository file to find the repository name for the given index
    ifstream repoNameFile(repoFileName);
    if (repoNameFile.is_open()) {
        for (int i = 0; i <= index; ++i) {
            getline(repoNameFile, repoName);
        }
        repoNameFile.close();
    }
    else {
        cerr << "Error: Unable to open " << repoFileName << "." << endl;
        Sleep(1000);
        return;
    }

    ifstream privateRepoFile(privateRepoFileName);
    if (privateRepoFile.is_open()) {
        string line;
        while (getline(privateRepoFile, line)) {
            size_t commaIndex = line.find(',');
            string repo = line.substr(0, commaIndex);
            if (repo == repoName) {
                isPrivate = true;
                break;
            }
        }
        privateRepoFile.close();
    }

    // Ask for password if the repository is private
    string enteredPassword, password;
    if (isPrivate) {
        cout << "Enter the password for the private repository '" << repoName << "': ";
        cin >> enteredPassword;
        // Now check if the password matches
        ifstream privateRepoFileCheck(privateRepoFileName);
        if (privateRepoFileCheck.is_open()) {
            string line;
            while (getline(privateRepoFileCheck, line)) {
                size_t commaIndex = line.find(',');
                string repo = line.substr(0, commaIndex);
                if (repo == repoName) {
                    password = line.substr(commaIndex + 1);
                    break;
                }
            }
            privateRepoFileCheck.close();
        }
        if (password != enteredPassword) {
            cout << "Incorrect password. Access denied." << endl;
            Sleep(1000);
            return;
        }
    }

    // Open the repository file for the specified repository name
    ifstream repositoryFile(repoName + ".txt");
    if (!repositoryFile.is_open()) {
        cerr << "Error: Unable to open repository file for reading." << endl;
        Sleep(1000);
        return;
    }

    // Display contents of the repository file
    cout << "Contents of repository '" << repoName << "' at index " << index << ":" << endl;
    Sleep(1000);
    string projectName;
    int projectIndex = 0;
    while (getline(repositoryFile, projectName)) {
        cout << ++projectIndex << ". " << projectName << endl;
    }
    repositoryFile.close();

    // Ask the user which project's contents they want to see
    int projectNumber;
    do {
        cout << "Enter the project number you want to display (0 to return to the main menu): ";
        cin >> projectNumber;
        if (projectNumber == 0) {
            return; // Return to main menu
        }
        else if (projectNumber < 1 || projectNumber > projectIndex) {
            cerr << "Invalid project number. Please enter a valid project number." << endl;
            Sleep(1000);
        }
        else {
            // Open and display contents of the selected project file
            ifstream projectFile(repoName + ".txt");
            if (projectFile.is_open()) {
                string projectLine;
                for (int i = 0; i < projectNumber; ++i) {
                    getline(projectFile, projectLine);
                }
                cout << "Contents of project '" << projectLine << "':" << endl;
                Sleep(1000);
                projectFile.close();
                ifstream projectContentFile(projectLine + ".txt");
                if (projectContentFile.is_open()) {
                    string line;
                    while (getline(projectContentFile, line)) {
                        cout << line << endl;
                    }
                    projectContentFile.close();
                    Sleep(1000);
                    return; // Exit function after displaying project contents
                }
                else {
                    cerr << "Error: Unable to open project file for reading." << endl;
                    Sleep(1000);
                    return;
                }
            }
            else {
                cerr << "Error: Unable to open repository file for reading." << endl;
                Sleep(1000);
                return;
            }
        }
    } while (true); // Repeat until a valid project number is entered or the user chooses to return to the main menu
}

//----------------------------------Function 31-------------------------------------------------------

void Repository::commitRepository(int hashVal)
{
    // Construct repository file name based on the hash value
    string repoFileName = "repositoryname" + to_string(hashVal) + ".txt";

    // Open repository file to find the repository names
    ifstream repoNameFile(repoFileName);
    string repoName;
    string repositories[100]; // Array to store repository names
    int repoCount = 0; // Variable to keep track of the number of repositories

    if (repoNameFile.is_open()) {
        while (getline(repoNameFile, repoName)) {
            repositories[repoCount] = repoName; // Store repository name in the array
            repoCount++;
            if (repoCount >= 100) // Ensure not to exceed the array size
                break;
        }
        repoNameFile.close();
    }
    else {
        cout << "Error: Unable to open " << repoFileName << "." << endl;
        Sleep(1000);
        return;
    }

    // Display all the repositories
    cout << "Repositories:" << endl;
    for (int i = 0; i < repoCount; ++i) {
        cout << i << ": " << repositories[i] << endl;
    }

    // Ask the user to select a repository index
    int index;
    cout << "Enter the index of the repository to commit: ";
    cin >> index;
    cin.ignore();

    // Check if the selected index is valid
    if (index < 0 || index >= repoCount) {
        cout << "Invalid repository index." << endl;
        return;
    }

    // Construct repository file name with the selected repository name
    string repositoryFileName = repositories[index] + ".txt";

    // Open the repository file for the selected repository name
    ifstream repositoryFile(repositoryFileName);
    if (!repositoryFile.is_open()) {
        cout << "Error: Unable to open repository file " << repositoryFileName << " for reading." << endl;
        Sleep(1000);
        return;
    }

    // Display contents of the repository file with line numbers
    cout << "Contents of repository '" << repositories[index] << "':" << endl;
    string projectName;
    int projectIndex = 1;
    while (getline(repositoryFile, projectName)) {
        cout << projectIndex++ << ". " << projectName << endl;
    }
    repositoryFile.close();

    // Prompt user to choose which project to commit
    int projectIndexToCommit;
    cout << "Enter the index of the project you want to commit: ";
    cin >> projectIndexToCommit;
    cin.ignore();

    // Construct project file name based on the selected project index
    string projectFileName = repositories[index] + to_string(projectIndexToCommit) + ".txt";

    // Open project file for appending
    ofstream projectToCommitFile(projectFileName, ios::app);
    if (!projectToCommitFile.is_open()) {
        cout << "Error: Unable to open project file " << projectFileName << " for appending." << endl;
        Sleep(1000);
        return;
    }

    // Prompt user to enter contents for committing
    string commitContent;
    cout << "Enter contents to commit to project '" << projectFileName << "': ";
    getline(cin, commitContent);
    projectToCommitFile << commitContent << endl;
    projectToCommitFile.close();

    cout << "Sucessfully commit in the file !!!" << endl;
    Sleep(1500);

    // Update commit counter
    string commitCounterFileName = "commitrepo" + to_string(hashVal) + ".txt";
    ifstream commitCounterFile(commitCounterFileName);
    if (!commitCounterFile) {
        // If commit counter file doesn't exist, create a new one
        ofstream newCommitCounterFile(commitCounterFileName);
        if (!newCommitCounterFile) {
            cout << "Error: Unable to create commit counter file " << commitCounterFileName << "." << endl;
            Sleep(1000);
            return;
        }
        newCommitCounterFile << repositories[index] << ",1" << endl;
        newCommitCounterFile.close();
    }
    else {
        // Update commit count for the selected repository
        string line;
        ofstream tempCommitCounterFile("temp.txt");
        bool repoFound = false;
        while (getline(commitCounterFile, line)) {
            size_t pos = line.find(",");
            string repo = line.substr(0, pos);
            if (repo == repositories[index]) {
                repoFound = true;
                int count = stoi(line.substr(pos + 1)) + 1;
                tempCommitCounterFile << repositories[index] << "," << count << endl;
            }
            else {
                tempCommitCounterFile << line << endl;
            }
        }
        commitCounterFile.close();
        tempCommitCounterFile.close();
        remove(commitCounterFileName.c_str());
        rename("temp.txt", commitCounterFileName.c_str());

        // If the repository was not found in the commit counter file, add it with count 1
        if (!repoFound) {
            ofstream newCommitCounterFile(commitCounterFileName, ios::app);
            if (!newCommitCounterFile) {
                cout << "Error: Unable to open commit counter file " << commitCounterFileName << " for appending." << endl;
                Sleep(1000);
                return;
            }
            newCommitCounterFile << repositories[index] << ",1" << endl;
            newCommitCounterFile.close();
        }
    }
}

//----------------------------------Function 32-------------------------------------------------------

void Repository::displayCommit(int hashVal) {

    //Opening the commitrepo with with a unique hash number where the commit record of each repository is saved
    ifstream commitCounterFile("commitrepo" + to_string(hashVal) + ".txt");
    if (commitCounterFile) {
        string line;
        cout << "Commits:" << endl;
        while (getline(commitCounterFile, line)) {
            size_t pos = line.find(",");
            string repo = line.substr(0, pos);
            int count = stoi(line.substr(pos + 1));
            cout << repo << " is committed " << count << " times." << endl;
        }
        commitCounterFile.close();
    }
    else {
        cout << "Error: Unable to open commit counter file." << endl;
    }
}

//----------------------------------Function 33-------------------------------------------------------

void Repository::setRepositoryName(const string& name)
{
    repositoryName = name;
}
//----------------------------------Function 33-------------------------------------------------------

string Repository::getRepositoryName(int index)
{
    if (index < 0 || index >= 100 || repositories[index] == nullptr) {
        cout << "Invalid repository index." << endl;
        Sleep(1000);
        return "";
    }
    // Return the repository name directly from the Repository class
    return repositoryName;
}
//----------------------------------Constructor-------------------------------------------------------

Friends::Friends()
{
    adjList = new FriendNode * [100];
    for (int i = 0; i < 100; ++i)
    {
        adjList[i] = nullptr;
    }
}
//----------------------------------Function 34-------------------------------------------------------

void Friends::addFriend(string userName, string friendName)
{
    // Get the hash value for the userName
    int hashVal = hashTable.gethash(userName);

    // Open the file to check if the friend name already exists
    string filename = "Friends" + to_string(hashVal) + ".txt";
    ifstream friendFile(filename);
    if (friendFile.is_open())
    {
        string name;
        while (getline(friendFile, name))
        {
            if (name == friendName)
            {
                cout << "Error: " << friendName << " is already in your friend list." << endl;
                Sleep(1000);

                friendFile.close();
                system("cls");
                return;
            }
        }
        friendFile.close();
    }

    // Create a new FriendNode with the given friendName
    FriendNode* newNode = new FriendNode(friendName);

    // Check if the adjacency list at hashVal index is empty
    if (adjList[hashVal] == nullptr)
    {
        adjList[hashVal] = newNode;
    }
    else
    {
        // If not empty, append the new FriendNode to the existing list
        newNode->nextPtr = adjList[hashVal];
        adjList[hashVal] = newNode;
    }

    // Store the friend name in a file named Friends+hashvalue.txt
    ofstream outFile(filename, ios::app);
    if (!outFile.is_open())
    {
        cout << "Error: Unable to open " << filename << " for writing." << endl;
        system("cls");
        return;
    }
    outFile << friendName << endl;
    outFile.close();
    cout << "Friend added successfully." << endl;
    Sleep(1000);

}

//----------------------------------Function 35-------------------------------------------------------

void Friends::unfollowFriend(string userName, string friendName)
{
    // Get the hash value for the userName
    int hashVal = hashTable.gethash(userName);

    // Open the file to read the friend names
    string filename = "Friends" + to_string(hashVal) + ".txt";
    ifstream friendFile(filename);
    if (!friendFile.is_open())
    {
        cout << "Error: Unable to open " << filename << " for reading." << endl;
        system("cls");
        return;
    }

    // Create a temporary file to store the updated content
    ofstream tempFile("temp.txt");
    if (!tempFile.is_open())
    {
        cout << "Error: Unable to create temporary file." << endl;
        friendFile.close();
        system("cls");
        return;
    }

    string name;
    bool found = false; // Flag to indicate if the friend to unfollow is found
    while (getline(friendFile, name))
    {
        if (name == friendName)
        {
            found = true; // Set the flag to true if the friend is found
        }
        else
        {
            tempFile << name << endl; // Write the friend name to the temporary file
        }
    }
    friendFile.close();
    tempFile.close();

    // If the friend to unfollow is not found, display a message and return
    if (!found)
    {
        cout << "Error: " << friendName << " is not in your friend list." << endl;
        Sleep(1000);
        system("cls");
        if (remove("temp.txt") != 0)
        {
            cout << "Error: Unable to delete temporary file." << endl;
            system("cls");
        }
        return;
    }

    // Replace the original file with the temporary file
    if (remove(filename.c_str()) != 0 || rename("temp.txt", filename.c_str()) != 0)
    {
        cout << "Error: Unable to update file." << endl;
        system("cls");
        return;
    }

    // Remove the friend node from the adjacency list
    FriendNode* current = adjList[hashVal];
    FriendNode* prev = nullptr;
    while (current != nullptr)
    {
        if (current->FriendName == friendName)
        {
            if (prev == nullptr)
            {
                adjList[hashVal] = current->nextPtr;
            }
            else
            {
                prev->nextPtr = current->nextPtr;
            }
            delete current;
            cout << "Friend " << friendName << " unfollowed successfully." << endl;

            Sleep(2000);
            system("pause");
            return;
        }
        prev = current;
        current = current->nextPtr;
    }
    if (!found)
        // If the friend node is not found in the adjacency list, display an error message
        cout << "Error: " << friendName << " is not in your friend list." << endl;
    system("cls");

}
//----------------------------------Function 36-------------------------------------------------------

void Friends::displayFriends(string userName)
{
    // Get the hash value for the userName
    int hashVal = hashTable.gethash(userName);

    cout << "Displaying Friends for " << userName << ":" << endl;
    cout << "------------------------------------------" << endl;

    // Open the file named Friends+hashvalue.txt
    string filename = "Friends" + to_string(hashVal) + ".txt";
    ifstream friendFile(filename);
    if (!friendFile.is_open())
    {
        cout << "Error: Unable to open " << filename << " for reading." << endl;
        return;
    }

    // Display friend names from the file
    string friendName;
    bool noFriends = true; // Flag to check if any friends are found
    while (getline(friendFile, friendName))
    {
        cout << "  - " << friendName << endl;
        noFriends = false; // Set the flag to false as at least one friend is found
        Sleep(1000);
    }
    friendFile.close();

    // If no friends were found in the file, print a message
    if (noFriends) {
        cout << "No friends added yet." << endl;
    }

    cout << "------------------------------------------" << endl;
    system("pause");
}



//----------------------------------Destructor-------------------------------------------------------

Friends::~Friends()
{
    // Free memory allocated for each linked list in the adjacency list
    for (int i = 0; i < 100; ++i)
    {
        FriendNode* current = adjList[i];
        while (current != nullptr)
        {
            FriendNode* temp = current;
            current = current->nextPtr;
            delete temp;
        }
    }
    // Free memory allocated for the array of pointers
    delete[] adjList;
}
//----------------------------------Function 37-------------------------------------------------------

void printBoxMain()
{
    system("cls");
    cout << "\n\n\n";
    cout << "\t\t\t\t\t" << "================================" << endl;
    cout << "\t\t\t\t\t" << "|     Repository Management    |" << endl;
    cout << "\t\t\t\t\t" << "================================" << endl;
    cout << "\t\t\t\t\t" << "| 1. Register                  |" << endl;
    cout << "\t\t\t\t\t" << "| 2. Login                     |" << endl;
    cout << "\t\t\t\t\t" << "| 3. Exit                      |" << endl;
    cout << "\t\t\t\t\t" << "================================" << endl;
    cout << endl;
}

//----------------------------------Function 38-------------------------------------------------------

void printBox() {
    system("cls"); // Clear screen for a cleaner output
    cout << "\n\n\n";
    cout << "\t\t\t\t\t" << "=====================================" << endl;
    cout << "\t\t\t\t\t" << "|      Repository Management        |" << endl;
    cout << "\t\t\t\t\t" << "=====================================" << endl;
    cout << "\t\t\t\t\t" << "| Menu:                             |" << endl;
    cout << "\t\t\t\t\t" << "| 1. Create new repository          |" << endl;
    cout << "\t\t\t\t\t" << "| 2. Add file to repository         |" << endl;
    cout << "\t\t\t\t\t" << "| 3. Delete file from repository    |" << endl;
    cout << "\t\t\t\t\t" << "| 4. Display contents of repository |" << endl;
    cout << "\t\t\t\t\t" << "| 5. Add Friend                     |" << endl;
    cout << "\t\t\t\t\t" << "| 6. Un_Follow Friend               |" << endl;
    cout << "\t\t\t\t\t" << "| 7. Display Friends                |" << endl;
    cout << "\t\t\t\t\t" << "| 8. Commit repository              |" << endl;
    cout << "\t\t\t\t\t" << "| 9. Display commit repository      |" << endl;
    cout << "\t\t\t\t\t" << "| 10. Logout                        |" << endl;
    cout << "\t\t\t\t\t" << "=====================================" << endl;
    cout << endl;
}
